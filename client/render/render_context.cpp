#include "render_context.hpp"
#include <iostream>

namespace mmo {

RenderContext::~RenderContext() {
    shutdown();
}

bool RenderContext::init(int width, int height, const std::string& title) {
    width_ = width;
    height_ = height;
    
    // Request OpenGL 4.6 Core Profile (for compute shaders, SSBOs, indirect draw)
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MAJOR_VERSION, 4);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_MINOR_VERSION, 6);
    SDL_GL_SetAttribute(SDL_GL_CONTEXT_PROFILE_MASK, SDL_GL_CONTEXT_PROFILE_CORE);
    SDL_GL_SetAttribute(SDL_GL_DOUBLEBUFFER, 1);
    SDL_GL_SetAttribute(SDL_GL_DEPTH_SIZE, 24);
    SDL_GL_SetAttribute(SDL_GL_MULTISAMPLEBUFFERS, 1);
    SDL_GL_SetAttribute(SDL_GL_MULTISAMPLESAMPLES, 4);
    
    window_ = SDL_CreateWindow(title.c_str(), width, height, 
                               SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);
    if (!window_) {
        std::cerr << "Failed to create window: " << SDL_GetError() << std::endl;
        return false;
    }
    
    gl_context_ = SDL_GL_CreateContext(window_);
    if (!gl_context_) {
        std::cerr << "Failed to create GL context: " << SDL_GetError() << std::endl;
        return false;
    }
    
    SDL_GL_MakeCurrent(window_, gl_context_);
    
    // Initialize GLEW
    glewExperimental = GL_TRUE;
    GLenum err = glewInit();
    if (err != GLEW_OK && !glGenVertexArrays) {
        std::cerr << "Failed to initialize GLEW: " << glewGetErrorString(err) << std::endl;
        return false;
    }
    // Clear any GL errors generated by GLEW init
    while (glGetError() != GL_NO_ERROR) {}
    
    SDL_GL_SetSwapInterval(1); // VSync
    
    // Default OpenGL setup
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
    glEnable(GL_MULTISAMPLE);
    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    
    std::cout << "OpenGL Renderer: " << glGetString(GL_RENDERER) << std::endl;
    std::cout << "OpenGL Version: " << glGetString(GL_VERSION) << std::endl;
    std::cout << "GLSL Version: " << glGetString(GL_SHADING_LANGUAGE_VERSION) << std::endl;
    
    return true;
}

void RenderContext::shutdown() {
    if (gl_context_) {
        SDL_GL_DestroyContext(gl_context_);
        gl_context_ = nullptr;
    }
    if (window_) {
        SDL_DestroyWindow(window_);
        window_ = nullptr;
    }
}

void RenderContext::update_viewport() {
    if (window_) {
        SDL_GetWindowSize(window_, &width_, &height_);
        glViewport(0, 0, width_, height_);
    }
}

void RenderContext::begin_frame() {
    update_viewport();
    glClearColor(clear_color_.r, clear_color_.g, clear_color_.b, clear_color_.a);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    // Reset to default state
    set_depth_test(true);
    set_culling(true);
}

void RenderContext::end_frame() {
    SDL_GL_SwapWindow(window_);
}

void RenderContext::set_depth_test(bool enabled) {
    if (enabled) {
        glEnable(GL_DEPTH_TEST);
    } else {
        glDisable(GL_DEPTH_TEST);
    }
}

void RenderContext::set_depth_write(bool enabled) {
    glDepthMask(enabled ? GL_TRUE : GL_FALSE);
}

void RenderContext::set_culling(bool enabled, GLenum face) {
    if (enabled) {
        glEnable(GL_CULL_FACE);
        glCullFace(face);
    } else {
        glDisable(GL_CULL_FACE);
    }
}

void RenderContext::set_blending(bool enabled, GLenum src, GLenum dst) {
    if (enabled) {
        glEnable(GL_BLEND);
        glBlendFunc(src, dst);
    } else {
        glDisable(GL_BLEND);
    }
}

} // namespace mmo
