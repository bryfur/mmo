# Model Scaling & Physics Architecture

## Problem Statement

Currently, model dimensions and scaling are handled inconsistently:

1. **Client** loads GLB files and knows exact bounds from mesh data
2. **Server** has hardcoded approximations of model dimensions
3. **Scaling is per-type only** — no support for unique instance sizes (e.g., a giant boss or small tree)
4. **Duplication** — target sizes defined in both `renderer.cpp` and `world.cpp`

This leads to potential mismatches between visual rendering and server-side physics collision.

---

## Proposed Solution

### 1. Build-Time Model Bounds Extraction

Create a build script that extracts bounding box data from all GLB files and generates a shared header.

#### Script: `tools/extract_model_bounds.py`

```python
#!/usr/bin/env python3
"""
Extract bounding box dimensions from GLB files and generate C++ header.
Run as part of the build process whenever models change.
"""

import struct
import json
import glob
import os

def extract_glb_bounds(filepath):
    """Extract min/max bounds from a GLB file."""
    with open(filepath, 'rb') as f:
        # GLB header
        magic, version, length = struct.unpack('<III', f.read(12))
        if magic != 0x46546C67:  # 'glTF'
            return None
        
        # JSON chunk
        chunk_length, chunk_type = struct.unpack('<II', f.read(8))
        json_data = json.loads(f.read(chunk_length).decode('utf-8'))
        
        # Find position accessor bounds
        for mesh in json_data.get('meshes', []):
            for prim in mesh.get('primitives', []):
                pos_idx = prim.get('attributes', {}).get('POSITION')
                if pos_idx is not None:
                    accessor = json_data['accessors'][pos_idx]
                    if 'min' in accessor and 'max' in accessor:
                        return {
                            'min': accessor['min'],
                            'max': accessor['max']
                        }
    return None

def generate_header(models_dir, output_path):
    """Generate C++ header with model bounds."""
    
    bounds_data = {}
    for glb_path in glob.glob(os.path.join(models_dir, '*.glb')):
        name = os.path.splitext(os.path.basename(glb_path))[0]
        bounds = extract_glb_bounds(glb_path)
        if bounds:
            bounds_data[name] = bounds
    
    with open(output_path, 'w') as f:
        f.write('''#pragma once
// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by tools/extract_model_bounds.py

#include <algorithm>
#include <string>
#include <unordered_map>

namespace mmo::config {

struct ModelBounds {
    float min_x, min_y, min_z;
    float max_x, max_y, max_z;
    
    float width() const { return max_x - min_x; }
    float height() const { return max_y - min_y; }
    float depth() const { return max_z - min_z; }
    float max_dimension() const { return std::max({width(), height(), depth()}); }
};

// Model bounds extracted from GLB files
inline const std::unordered_map<std::string, ModelBounds>& get_all_model_bounds() {
    static const std::unordered_map<std::string, ModelBounds> bounds = {
''')
        
        for name, b in sorted(bounds_data.items()):
            min_v = b['min']
            max_v = b['max']
            f.write(f'        {{"{name}", {{{min_v[0]:.6f}f, {min_v[1]:.6f}f, {min_v[2]:.6f}f, ')
            f.write(f'{max_v[0]:.6f}f, {max_v[1]:.6f}f, {max_v[2]:.6f}f}}}},\n')
        
        f.write('''    };
    return bounds;
}

inline const ModelBounds* get_model_bounds(const std::string& model_name) {
    const auto& all_bounds = get_all_model_bounds();
    auto it = all_bounds.find(model_name);
    return it != all_bounds.end() ? &it->second : nullptr;
}

} // namespace mmo::config
''')

if __name__ == '__main__':
    generate_header('assets/models', 'common/model_bounds_generated.hpp')
    print("Generated common/model_bounds_generated.hpp")
```

#### Generated Output: `common/model_bounds_generated.hpp`

```cpp
// AUTO-GENERATED - example output
inline const std::unordered_map<std::string, ModelBounds>& get_all_model_bounds() {
    static const std::unordered_map<std::string, ModelBounds> bounds = {
        {"building_tavern", {-0.5f, -0.48f, -0.5f, 0.5f, 0.50f, 0.5f}},
        {"building_tower", {-0.3f, -0.50f, -0.3f, 0.3f, 0.50f, 0.3f}},
        {"mage", {-0.25f, -0.50f, -0.25f, 0.25f, 0.50f, 0.25f}},
        // ... all models
    };
    return bounds;
}
```

---

### 2. Shared Entity Configuration

Create a single source of truth for target sizes (design decisions).

#### File: `common/entity_config.hpp`

```cpp
#pragma once

#include "protocol.hpp"
#include "model_bounds_generated.hpp"

namespace mmo::config {

// ============================================================================
// Target Sizes (Design Decisions - SINGLE SOURCE OF TRUTH)
// These control how big entities appear in the world
// ============================================================================

inline float get_building_target_size(BuildingType type) {
    switch (type) {
        case BuildingType::Tower:       return 160.0f;
        case BuildingType::Tavern:      return 140.0f;
        case BuildingType::Blacksmith:  return 120.0f;
        case BuildingType::Shop:        return 100.0f;
        case BuildingType::House:       return 110.0f;
        case BuildingType::Well:        return 60.0f;
        case BuildingType::Inn:         return 150.0f;
        case BuildingType::WoodenLog:   return 60.0f;
        case BuildingType::LogTower:    return 140.0f;
        default:                        return 100.0f;
    }
}

inline float get_character_target_size(EntityType type) {
    switch (type) {
        case EntityType::Player:  return 32.0f;
        case EntityType::NPC:     return 36.0f;
        case EntityType::TownNPC: return 32.0f * 0.9f;
        default:                  return 32.0f;
    }
}

// ============================================================================
// Model name mapping (for bounds lookup)
// ============================================================================

inline const char* get_building_model_name(BuildingType type) {
    switch (type) {
        case BuildingType::Tower:       return "building_tower";
        case BuildingType::Tavern:      return "building_tavern";
        case BuildingType::Blacksmith:  return "building_blacksmith";
        case BuildingType::Shop:        return "building_shop";
        case BuildingType::House:       return "building_house";
        case BuildingType::Well:        return "building_well";
        case BuildingType::Inn:         return "inn";
        case BuildingType::WoodenLog:   return "wooden_log";
        case BuildingType::LogTower:    return "log_tower";
        default:                        return "building_house";
    }
}

// ============================================================================
// Scale Calculation (used by both client and server)
// ============================================================================

inline float calculate_base_scale(const ModelBounds& bounds, float target_size) {
    return (target_size * 1.5f) / bounds.max_dimension();
}

// Get final world-space size for collision
inline float get_collision_radius(float target_size, float instance_scale = 1.0f) {
    return target_size * instance_scale * 0.35f;
}

inline float get_collision_half_height(float target_size, float instance_scale = 1.0f) {
    return target_size * instance_scale * 0.4f;
}

} // namespace mmo::config
```

---

### 3. Per-Instance Scale in Network Protocol

Add a scale field to `NetEntityState` for per-instance sizing.

#### Changes to `common/protocol.hpp`

```cpp
struct NetEntityState {
    uint32_t id = 0;
    EntityType type = EntityType::Player;
    PlayerClass player_class = PlayerClass::Warrior;
    NPCType npc_type = NPCType::Monster;
    BuildingType building_type = BuildingType::Tavern;
    float x = 0.0f;
    float y = 0.0f;
    float vx = 0.0f;
    float vy = 0.0f;
    float rotation = 0.0f;
    float health = 100.0f;
    float max_health = 100.0f;
    uint32_t color = 0xFFFFFFFF;
    char name[32] = {0};
    bool is_attacking = false;
    float attack_cooldown = 0.0f;
    float attack_dir_x = 0.0f;
    float attack_dir_y = 1.0f;
    
    // NEW: Per-instance scale multiplier (1.0 = default size)
    float scale = 1.0f;
    
    // serialized_size() needs update to include scale
};
```

#### ECS Component: `common/ecs/components.hpp`

```cpp
// Per-instance scale component
struct Scale {
    float value = 1.0f;  // Multiplier: 1.0 = normal, 2.0 = double size, 0.5 = half
};
```

---

### 4. Server-Side Physics Using Shared Config

The server uses the same config as the client for collision sizing.

#### Server Entity Creation (world.cpp)

```cpp
#include "common/entity_config.hpp"

void World::spawn_building(BuildingType type, float x, float y, float rotation, 
                           const char* name, float instance_scale = 1.0f) {
    auto entity = registry_.create();
    
    registry_.emplace<ecs::NetworkId>(entity, next_network_id());
    registry_.emplace<ecs::Transform>(entity, x, y, rotation);
    registry_.emplace<ecs::Scale>(entity, instance_scale);  // Store per-instance scale
    
    // Get model bounds from generated header
    const char* model_name = config::get_building_model_name(type);
    const auto* bounds = config::get_model_bounds(model_name);
    
    float target_size = config::get_building_target_size(type);
    float base_scale = bounds ? config::calculate_base_scale(*bounds, target_size) : 1.0f;
    float final_scale = base_scale * instance_scale;
    
    // Physics collider sized correctly
    ecs::Collider collider;
    collider.type = ecs::ColliderType::Box;
    if (bounds) {
        collider.half_extents_x = (bounds->width() * final_scale) * 0.4f;
        collider.half_extents_y = (bounds->height() * final_scale) * 0.5f;
        collider.half_extents_z = (bounds->depth() * final_scale) * 0.4f;
    }
    registry_.emplace<ecs::Collider>(entity, collider);
    
    // ... rest of entity setup
}

// Example: Create a giant tower (2x normal size)
spawn_building(BuildingType::Tower, 1000.0f, 1000.0f, 0.0f, "Giant Tower", 2.0f);

// Example: Create a small decorative well (0.5x size)
spawn_building(BuildingType::Well, 500.0f, 500.0f, 0.0f, "Small Well", 0.5f);
```

---

### 5. Client Rendering Using Network Scale

The client uses the scale value received from the server.

#### Client Rendering (renderer.cpp)

```cpp
#include "common/entity_config.hpp"

void Renderer::render_entity(const NetEntityState& entity) {
    Model* model = get_model_for_entity(entity);
    if (!model) return;
    
    // Get base target size from shared config
    float target_size;
    switch (entity.type) {
        case EntityType::Building:
            target_size = config::get_building_target_size(entity.building_type);
            break;
        case EntityType::Player:
        case EntityType::NPC:
        case EntityType::TownNPC:
            target_size = config::get_character_target_size(entity.type);
            break;
    }
    
    // Apply per-instance scale from server
    float model_size = model->max_dimension();
    float scale = (target_size * entity.scale * 1.5f) / model_size;
    
    // Render with calculated scale
    render_model(model, entity.x, entity.y, entity.rotation, scale);
}
```

---

## Data Flow Summary

```
┌─────────────────────────────────────────────────────────────────────┐
│                        BUILD TIME                                    │
├─────────────────────────────────────────────────────────────────────┤
│  GLB Files ──► extract_model_bounds.py ──► model_bounds_generated.hpp │
└─────────────────────────────────────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      SHARED (common/)                                │
├─────────────────────────────────────────────────────────────────────┤
│  model_bounds_generated.hpp  ◄── Exact bounds from GLB files         │
│  entity_config.hpp           ◄── Target sizes (design decisions)     │
│  protocol.hpp                ◄── NetEntityState with scale field     │
└─────────────────────────────────────────────────────────────────────┘
                    │                           │
                    ▼                           ▼
┌────────────────────────────┐    ┌────────────────────────────┐
│         SERVER             │    │         CLIENT             │
├────────────────────────────┤    ├────────────────────────────┤
│ • Spawns entities with     │    │ • Receives entity state    │
│   per-instance scale       │    │   including scale          │
│ • Uses shared config for   │───►│ • Uses shared config for   │
│   physics collision sizing │    │   base target size         │
│ • Sends scale in network   │    │ • Applies scale to model   │
│   state                    │    │   rendering                │
└────────────────────────────┘    └────────────────────────────┘
```

---

## Benefits

| Aspect | Before | After |
|--------|--------|-------|
| **Model bounds** | Hardcoded guesses on server | Extracted from actual GLB files |
| **Target sizes** | Duplicated in 2 files | Single source in `entity_config.hpp` |
| **Instance scale** | All same-type entities identical | Per-entity scale multiplier |
| **Physics accuracy** | Approximate | Exact match to visual size |
| **Maintenance** | Change 2 places | Change 1 place |

---

## Implementation Checklist

- [ ] Create `tools/extract_model_bounds.py`
- [ ] Add to CMake build to run when models change
- [ ] Create `common/entity_config.hpp` with shared config
- [ ] Add `scale` field to `NetEntityState` in protocol.hpp
- [ ] Add `Scale` component to ECS
- [ ] Update `NetEntityState::serialize()` / `deserialize()`
- [ ] Update server `World::spawn_*` functions to use shared config
- [ ] Update server physics collision sizing
- [ ] Update client renderer to use `entity.scale`
- [ ] Remove duplicated constants from `world.cpp` and `renderer.cpp`

---

## Future Enhancements

1. **Non-uniform scaling** — Add `scale_x`, `scale_y`, `scale_z` for stretched objects
2. **LOD support** — Different collision shapes at different distances
3. **Collision shape types** — Store preferred shape (box/capsule/convex) in model metadata
4. **Hot reload** — Regenerate bounds header when models change during development
