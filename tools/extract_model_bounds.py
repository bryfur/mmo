#!/usr/bin/env python3
"""
Extract bounding box dimensions from GLB files and generate C++ header.
Run as part of the build process whenever models change.

Usage: python tools/extract_model_bounds.py
"""

import struct
import json
import glob
import os
import sys


def extract_glb_bounds(filepath):
    """Extract min/max bounds from a GLB file."""
    try:
        with open(filepath, 'rb') as f:
            # GLB header
            magic, version, length = struct.unpack('<III', f.read(12))
            if magic != 0x46546C67:  # 'glTF'
                print(f"  Warning: {filepath} is not a valid GLB file")
                return None
            
            # JSON chunk
            chunk_length, chunk_type = struct.unpack('<II', f.read(8))
            if chunk_type != 0x4E4F534A:  # 'JSON'
                print(f"  Warning: {filepath} missing JSON chunk")
                return None
                
            json_data = json.loads(f.read(chunk_length).decode('utf-8'))
            
            # Find position accessor bounds
            for mesh in json_data.get('meshes', []):
                for prim in mesh.get('primitives', []):
                    pos_idx = prim.get('attributes', {}).get('POSITION')
                    if pos_idx is not None:
                        accessor = json_data['accessors'][pos_idx]
                        if 'min' in accessor and 'max' in accessor:
                            return {
                                'min': accessor['min'],
                                'max': accessor['max']
                            }
    except Exception as e:
        print(f"  Error reading {filepath}: {e}")
        return None
    
    return None


def generate_header(models_dir, output_path):
    """Generate C++ header with model bounds."""
    
    bounds_data = {}
    glb_files = sorted(glob.glob(os.path.join(models_dir, '*.glb')))
    
    print(f"Extracting bounds from {len(glb_files)} GLB files...")
    
    for glb_path in glb_files:
        name = os.path.splitext(os.path.basename(glb_path))[0]
        bounds = extract_glb_bounds(glb_path)
        if bounds:
            bounds_data[name] = bounds
            min_v = bounds['min']
            max_v = bounds['max']
            print(f"  {name}: Y=[{min_v[1]:.6f}, {max_v[1]:.6f}]")
        else:
            print(f"  {name}: FAILED to extract bounds")
    
    print(f"\nGenerating {output_path}...")
    
    with open(output_path, 'w') as f:
        f.write('''#pragma once
// AUTO-GENERATED FILE - DO NOT EDIT
// Generated by tools/extract_model_bounds.py
// Re-run this script when models are added or modified

#include <algorithm>
#include <string>
#include <unordered_map>

namespace mmo::config {

/// Bounding box dimensions extracted from GLB model files
struct ModelBounds {
    float min_x, min_y, min_z;
    float max_x, max_y, max_z;
    
    /// Width of the model (X axis)
    constexpr float width() const { return max_x - min_x; }
    
    /// Height of the model (Y axis - vertical in model space)
    constexpr float height() const { return max_y - min_y; }
    
    /// Depth of the model (Z axis)
    constexpr float depth() const { return max_z - min_z; }
    
    /// Maximum dimension (used for uniform scaling)
    float max_dimension() const { return std::max({width(), height(), depth()}); }
};

/// Get all model bounds extracted from GLB files
inline const std::unordered_map<std::string, ModelBounds>& get_all_model_bounds() {
    static const std::unordered_map<std::string, ModelBounds> bounds = {
''')
        
        for name, b in sorted(bounds_data.items()):
            min_v = b['min']
            max_v = b['max']
            f.write(f'        {{"{name}", {{{min_v[0]:.6f}f, {min_v[1]:.6f}f, {min_v[2]:.6f}f, ')
            f.write(f'{max_v[0]:.6f}f, {max_v[1]:.6f}f, {max_v[2]:.6f}f}}}},\n')
        
        f.write('''    };
    return bounds;
}

/// Get bounds for a specific model by name (returns nullptr if not found)
inline const ModelBounds* get_model_bounds(const std::string& model_name) {
    const auto& all_bounds = get_all_model_bounds();
    auto it = all_bounds.find(model_name);
    return it != all_bounds.end() ? &it->second : nullptr;
}

} // namespace mmo::config
''')
    
    print(f"Successfully generated header with {len(bounds_data)} model bounds")
    return len(bounds_data)


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser(description='Extract model bounds from GLB files')
    parser.add_argument('--models-dir', required=True, help='Path to directory containing GLB files')
    parser.add_argument('--output', required=True, help='Output header file path')
    args = parser.parse_args()

    if not os.path.isdir(args.models_dir):
        print(f"Error: Models directory not found: {args.models_dir}")
        sys.exit(1)

    os.makedirs(os.path.dirname(args.output), exist_ok=True)

    count = generate_header(args.models_dir, args.output)
    if count == 0:
        print("Warning: No model bounds were extracted!")
        sys.exit(1)

    print(f"\nDone! Generated {args.output}")
